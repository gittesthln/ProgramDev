%-*- coding: utf-8 -*-
\chapter{JavaScriptが取り扱うデータ}
\section{データーの型}
JavaScript の方には大きく分けて\KeyItem{プリミティブ型}と\KeyItem{非プリ
ミティブ型}の2種類がある。
\subsection{プリミティブデータ型}
表\ref{primitivedata}はJavaScriptにおける\KeyItem{プリミティブデータ型}の一覧であ
る。
 \begin{table}[ht]
  \caption{プリミティブデータ型}\label{primitivedata}
\begin{center}
\begin{tabular}{|c|m{30zw}|}\hline
 型&\multicolumn{1}{c|}{説明} \\\hline
 \ElmJ{Number} & 浮動小数点数だけ\\ \hline
 \ElmJ{String} & \KeyItem{文字列型}、1文字だけのデータ型はない。ダブルク
     オート(\Verb+"+)か%" 
     シングルクオート(\Verb+'+)で囲む。\\ \hline
 \ElmJ{Boolean}& \ElmJ{true} か \ElmJ{false} の値のみ\\ \hline
 \ElmJ{undefined} & 変数の値が定義されていないことを示す\\ \hline
 \ElmJ{null}& \ElmJ{null}という値しか取ることができない特別なオブジェク
     ト\\ \hline
\end{tabular}
\end{center}
 \end{table}

 変数や値の型を知りたいときは\ElmJ{typeof} 演算子を使う。
\subsection{Number型}
JavaScriptで扱う数は64ビット浮動小数点形式である。数を表現する方法(数値
リテラル)としては次のものがある。
\begin{itemize}
 \item{\bfseries \KeyItem{整数リテラル}} 10進整数は通常通りの形式である。
      \KeyItem{16進数}を表す場合は
	      先頭に\Verb+0x+ か \Verb+0X+ をつける。\Verb+0+で始まりそ
	      のあとに\Verb+x+または\Verb+X+が来ない場合には\KeyItem{8進数}と解釈
      される場合がある
      %\footnote{Opera, Internet Exploler, FireFox, Chrome では8進数と解釈されるようである。}。
      \Strict ではこの形式はエラーとなる。

      2進数は\Verb+0b+ で、8進数は\Verb+0o+で始まるリテラルが定義されて
      いる。
 \item{\bfseries \KeyItem{浮動小数点リテラル}} 整数部、そのあとに必要ならば小数点、小数部そ
       のあとに指数部がある形式である。
\end{itemize}
{\bfseries 特別なNumber} \KeyItem{Number型}には次のような特別な Number が定義され
ている。
\begin{itemize}
 \item {\bfseries \ElmJ{Infinity}}無限大を表す読み出し可能な変数である。
       オーバーフローした場合や \Verb+1/0+ など演算の結果としてこの値が設定さ
       れる。
 \item {\bfseries \ElmJ{NaN}} Not a Number の略である。計算ができなかった場合
       表す読み出し可能な変数である。
       文字列を数値に変換できない場合や \Verb+0/0+ などの結果としてこの値が設定さ
       れる。
\end{itemize}
\subsection{String型}
文字列に関する演算子としては、2つの文字列をつなげる\KeyItem{連接演算子}
がある。JavaScript では\ElmJ{+}を用いる。詳しくは\ref{operator}を参照の
こと。

\KeyItem{文字列}に関する情報(プロパティ)や操作(メソッド)として次の
ものがある。
\begin{table}[ht]
 \caption{文字列のメソッドとプロパティ}\label{methodStrig}
\begin{center}
 \begin{tabular}{|c|m{28zw}|}\hline
 メンバー&\multicolumn{1}{c|}{説明} \\\hline
  \ElmJP{length} &文字列の長さ\\ \hline
\ElmJF{indexOf}{needle,start}& \Verb+needle+が与えられた文字列内にあ
      ればそれが初めて現れる位置を返す。\Verb+start+の引数がある場合には、指定された位
      置以降から調べる。見つからない場合は$-1$を返す。\\\hline
\ElmJF{lastIndexOf}{needle,start}& \Verb+needle+が与えられた文字列内にあ
      ればそれが一番最後に現れる位置を返す。\Verb+start+の引数がある場合
      には、指定された位置以前から調べる。見つからない場合は$-1$を返す。\\\hline
  \ElmJF{split}{separator,limit}&\Verb+separator+で与えられた文字列(ま
      たは正規表現)で与え
      られた文字列を分けて配列で返す。セパレーターの部分は返されない。
      2番目の引数はオプションで、分割する最大数を返す。\\ \hline
  \ElmJF{substring}{start,end}&与えられた文字列の\Verb+start+から
      \Verb+end+の前の位置までの部分文字列を返す。\\ \hline
  \ElmJF{slice}{start,end}&与えられた文字列の\Verb+start+から
      \Verb+end+の前の位置までの部分文字列を返す。値が負の場合には文字列
      の最後から数えた位置を表す。\\ \hline
\end{tabular}
\end{center}
\end{table}

この表に現れる正規表現については後日解説をする。
\begin{Exec}\upshape
 次の実行結果を確かめなさい。
 \begin{enumerate}
	\item \texttt{"0123456789".indexOf("1");}
	\item \texttt{"0123456789".indexOf("a");}
	\item \texttt{"0123456789".indexOf("1",2);}
	\item \texttt{"0,1,2,3".split(",");}
	\item \texttt{"0,1,2,3".split(",",2);}
	\item \texttt{"0123".split("");}
	\item \texttt{"0123456789".substring(3);}
	\item \texttt{"0123456789".substring(-3);}
	\item \texttt{"0123456789".slice(-3);}
	\item \texttt{"0123456789".substring(3,5);}
	\item \texttt{"0123456789".slice(3,5);}
	\item \texttt{"0123456789".slice(3,-3);}
 \end{enumerate}
\end{Exec}
\iffalse
\begin{Prob}\upshape
 与えられた文字列の最後の3つの部分の文字列を得る(文字列
 \texttt{"0123456789"}に対しては\texttt{"789"}を返す)ためにはどのようにすれば
 よいか。
\end{Prob}
\fi
  \subsection{Bool型}
\ElmJ{true} と \ElmJ{false} の2つの値をとる。この2つは予約語である。論理
式の結果としてこれらの値が設定されたり、論理値が必要なところでこれらの値
に設定される。詳しくは\ref{operator}を参照のこと。
\subsection{\protect\ElmJ{undefined}}
値が存在しないことを示す読み出し可能な変数である。変数が宣言されたのに値
が設定されていないときの初期値や、戻り値が定義されていない関数の戻り値はこの値に
なる。
\subsection{\protect\ElmJ{null}}
\Verb+typeof null+ の値が \Verb+"object"+であることを示すように、オブジェ
クトが存在しないことを示す特別なオブジェクト値（であると同時にオブジェク
トでもある）である。
\section{変数}
JavaScriptの変数の特徴は次の通りである。
\begin{itemize}
 \item 変数名はアルファベットまたは\Verb+_+(アンダースコア)で始まる英数
       字または\Verb+_+ が続く文字列
 \item 大文字と小文字は区別される。
 \item 変数の宣言は \texttt{var} で行う。
 \item 宣言時に初期化ができる。
 \item 非\Strict のときは変数は宣言をしなくても使用できる。初期化してい
       ない変数を演算の対象として使用するとエラーが起こる。詳しくは後述する。
 \item 変数に保存するデータの型には制限がない。途中で変更することもでき
       る。
\end{itemize}
\section{配列}
\subsection{配列の宣言と初期化}
配列を使うためには、変数を配列で初期化する必要がある。変数の宣言と同時に
行ってもよい。
\begin{Verbatim}
var a = [];
var b = [1,2,3];
\end{Verbatim}
\Verb+a+ は空の配列で初期化されている。\Verb+b+ は　
\Verb+b[0]=1,b[1]=2,b[2]=3+ となる配列で初期化されている。
次のことに注意する必要がある。
\begin{itemize}
 \item 配列の各要素のデータの型は同じでなくてもよい。
 \item 実行時に配列の大きさを自由に変えられる。
 \item 配列の要素に配列を置くことができる。
\begin{Verbatim}
var a=[1,[2,3,4],"a"];
\end{Verbatim}
\end{itemize}
\subsection{配列のメソッド}
表\ref{arrayPropMethod}は配列のメソッドやプロパティをまとめたものである。
\begin{table}[ht]
\caption{配列のメソッドとプロパティ}\label{arrayPropMethod}
\begin{center}
 \begin{tabular}{|c|m{28zw}|}\hline
 メンバー&\multicolumn{1}{c|}{説明} \\\hline
  \Verb+length+ &配列の要素の数\\ \hline
  \Verb+join(separator)+& 配列を文字列に変換する。\Verb+separator+はオプ
      ションの引数で、省略された場合はカンマ\Verb+,+である。\\ \hline
  \Verb+pop()+& 配列の最後の要素を削除し、その値を返す。配列をスタックと
      して利用できる。\\ \hline
  \Verb+push(i1,i2,...)+& 引数で渡された要素を配列の最後に付け加える。配
      列をスタックやキューとして利用できる。\\ \hline
  \Verb+shift()+&配列の最初の要素を削除し、その値を返す。配列をキューと
      して利用できる。\\ \hline
  \Verb+slice(start,end)+&\Verb+start+から\Verb+end+の前の位置にある要素を取
      り出した配列を返す。元の配列は変化しない。\\ \hline
  \Verb+splice(start,No,i1,i2,...)+&\Verb+start+の位置から\Verb+No+の要素を取
      り除き、その位置に\Verb+i1,i1,...+以下の要素を付け加える。元の配列
      を変更する。\\ \hline
\end{tabular}
\end{center}
\end{table}
\begin{Exec}\upshape
 次の実行結果を確かめなさい
\begin{enumerate}\upshape
 \item \texttt{[1,2,[],3].length;}
 \item \texttt{var a=[1,2,3]; console.log(a.pop()); console.log(a.length);a;}
 \item \texttt{var a=[1,2,3]; a.push(4,5); console.log(a.length);a;}
 \item \texttt{var a=[1,2,3]; a.shift(4,5); console.log(a.length);a;}
 \item \texttt{var a=[1,2,3]; a.join(" ");
 \item \texttt{var a=[1,2,3,4,5]; console.log(a.slice(1,2)); console.log(a.length);a;}
 \item var a=[1,2,3,4,5]; console.log(a.splice(1,2)); console.log(a.length);a;}
\end{enumerate}
\end{Exec}

\section{演算子}\label{operator}
\subsection{代入、四則演算}
数に対してはC言語と同様の演算子が使用できる。ただし、次のことに注意する
こと。
\begin{itemize}
 \item \Verb-+-演算子は文字列の連接にも使用できる。\Verb-+-演算子は左右のオペ
ランドがNumberのときだけ、数の和をとる。どちらかが数でもう一方が文字列の
場合は数を文字列に直して、文字列の連接を行う。
\begin{Verbatim}
1+2  => 3
1+"2" => 12
\end{Verbatim}
 \item そのほかの演算子(\Verb+-*/+)については文字列を数に変換してから数
       として計算する。
 \item 文字列全体が数にならない場合には変換の結果が\Verb+NaN+になる。
\begin{Verbatim}
 "2" + 3  => "23"
 "2"-0 +3 => 5
 "2"*3    => 6
 "2"*"3"  => 6
 "f" *2   => NaN
 "f" *2   => NaN
 "0xf"*2  => 30
 "0o10"*2 => 16
 "010"*2  => 20
\end{Verbatim}
 \item 整数を整数で割った場合、割り切れなければ小数となる。
       小数部分を切り捨てたいときは\Verb+Math.floor()+を用いる。
\begin{Verbatim}
1/3 => 0.3333333333333333
Math.floor(1/3) =>0
\end{Verbatim}
\end{itemize}
\subsection{論理演算子と比較演算子}
\subsubsection{論理演算子}
Boolean 型に対して使用できる演算子は次の3つである。
\begin{itemize}
 \item \Verb+!+ 論理否定
 \item \Verb+&&+ 論理積
 \item \Verb+||+ 論理和
\end{itemize}
論理演算子をBoolean 型でない値を与えると元の値がBoolean型に変換されてか
ら実行される。次の値は \Verb+false+ に変換される。
\begin{itemize}
 \item 空文字列 \Verb+""+
 \item \Verb+null+
 \item \Verb+undefined+
 \item 数字の $0$
 \item 数値の \Verb+NaN+
 \item Boolean の\Verb+false+
\end{itemize}
論理和や論理積では左のオペランドの結果により、式の値が決まる場合は右のオ
ペランドの評価は行われない。たとえば、論理和の場合、左の値が
\Verb+true+であれば右のオペランドの評価が行われない。
\begin{Verbatim}
var a=1; true ||(a=3); 
\end{Verbatim}
では変数 \Verb+a+ の値は $1$ のままである。
\subsubsection{比較演算子}
比較演算子は比較の結果、Boolean の値を返す演算である。C言語と同様の比較
演算子が使用できる。\texttt{>,>=,<,<=}など。等しいことを比較するためには
\Verb+==+(等価比較演算子)のほかに 型変換を伴わない等価比較演算子
\Verb+===+ がある。等価比較演算子\texttt{==}は必要に応じて型変換を行う。
\begin{Verbatim}
0 == "0" => true
0 === "0" => false
\end{Verbatim}
同様に非等価比較演算子\texttt{!=}にも型変換を伴わない非等価演算子
\texttt{!==}がある。

また、\Verb+NaN == NaN+ の結果は \Verb+false+ である。そのために値が \Verb+NaN+ で
あるかどうかを調べる関数(\ElmJ{isNaN()})がある。
\section{組み込みオブジェクト}
\subsection{組み込み関数}
JavaScript に初めから組み込まれている関数としては次のものがある。
\begin{itemize}
 \item \Verb+parseInt(string,radix)+ \Verb+string+(文字列)と
       \Verb+radix+(基数、省略したときは$10$)をとり、先頭から見て正しい
       整数表現のところまで整数に変換する。
 \item \ElmJ{parseFloat(string)} \Verb+string+(文字列)
       をとり、先頭から見て正しい
       浮動小数点表現のところまで浮動小数に変換する。
 \item \Verb+isNaN(N)+ \Verb+N+ が数であれば \Verb+true+、そうでなければ
       \Verb+false+ を返す。
 \item \Verb+isFinite(N)+ \Verb+N+ が数値または数値に変換できる値でかつ
       \Verb+Infinity+ または \Verb+-Infinity+ でないときに \Verb+true+、
       そうでないとき、\Verb+false+ を返す。
 \item \ElmJ{encodeURIComponent(string)} \texttt{string}を URLエンコー
			 ドする。Google の検索で日本語を含むものを対象とすると、アドレス
			 バーに\%で始まる文字列が見えるが、これがURLエンコードした結果で
			 ある。 
 \item \ElmJ{decodeURIComponent(string)}
			 \ElmJ{encodeURIComponent(string)}の逆の操作をする。
 \item \ElmJ{encodeURI(string)} \texttt{string} をURIエンコーディングす
			 る。この関数はプロトコル部分などはエンコードしない。
 \item \ElmJ{decodeURI(string)} \ElmJ{encodeURI(string)} の逆の操作をす
			 る。
\end{itemize}
このほかにも関数があるが、省略する。
%\newpage
%\clearpage
\subsection{\protect\texttt{Dateオブジェクト}}
日付や時間に関するデータを扱うコンストラクタ関数である。

引数は、年、月、日、時、分、秒、ミリ秒の順で設定される。
\begin{Verbatim}
>new Date(2015,10,2,10,10,20,500);
Mon Nov 02 2015 10:10:20 GMT+0900 (東京 (標準時))
\end{Verbatim}
省略された引数は \texttt{0} が設定されたものとみなされる。月の値は
\texttt{0} が1月を表す。上記の例では月の値\texttt{10}となっているので11
月に設定されている。

引数がなく使用すると、現在の日時を設定したものと解釈される。
\begin{Verbatim}
>new Date()
Thu Oct 01 2015 13:17:46 GMT+0900 (東京 (標準時))
\end{Verbatim}
なお、\Verb+Date+オブジェクトの\texttt{getTime()}メソッドで得られるタイ
ムスタンプの値は世界標準時(UTC)において1970年1月1日0時が基準となっていて
単位はミリ秒である。
\input 00Date.tex

\begin{Prob}\upshape\label{DateProb}
 次の日時を求める式を答えよ。
 \begin{enumerate}
	\item 与えられた日時から1週間後の日時
	\item 与えられた日時の翌月の1日
	\item 与えられた日時の前の月の最終日
	\item 与えられた日時の月の第1月曜日
 \end{enumerate}
\end{Prob}
\clearpage
\subsection{\protect\texttt{Math}オブジェクト}
\ElmJ{Math}オブジェクトには数学的な定数の定義(円周率など)や三角関数など
の関数が定義されている。表\ref{JSMath}はそれらのプロパティや関数をまとめ
たものである。
\input 00Math.tex
%
\clearpage
\section{第2回目復習課題}
%
\Answertrue
%\Answerfalse
\input prob02.tex
