%-*- coding: utf-8 -*-
\documentclass[dvipsk]{beamer}
\usepackage{pgfpages}
\usepackage{moreverb,array}
%\usetheme{Malmoe}
%
\usetheme{Goettingen} %7 8 9
%\usetheme{Darmstadt}% 1, 2, 3
%\usetheme{Boadilla}
%\usetheme{CambridgeUS}%4, 5 6 
%\usetheme{AnnArbor}
%\usetheme{Marburg}
\iffalse\else
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\kanjifamilydefault}{\gtdefault}
\setbeamerfont{title}{size=\Large,series=\bfseries}%,color=white}
\setbeamerfont{frametitle}{size=\large,series=\bfseries}
\setbeamerfont{beamergotobutton}{size=\Large}
%\setbeamercolor{frametitle}{fg=yellow}
\setbeamertemplate{frametitle}[default][center]
%\addtobeamertemplate{footline}{}{\insertframenumber/\inserttotalframenumber}
\usefonttheme{professionalfonts}
\fi
%\iftrue
\title{ソフトウェア開発\\第8回目授業}
\author{平野 照比古}
\institute{}
\date{2015/11/20}
\newtheorem{Prob}{解説}
\newcommand{\Elm}[1]{\texttt{<#1>}}
\setbeamercovered{transparent}
\begin{document}
\frame{\maketitle}
%\frame{\tableofcontents}
\section{HTML文書の構成}
\begin{frame}[containsverbatim]
\frametitle{\texttt{Google Maps} の利用(1)}
次のリストは\texttt{Google Maps} を利用して地図を表示するものである。
{\small
\begin{listing}[5]{1}
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" 
   content="text/html; charset=utf-8"/>
<title>初めてのGoogleMaps</title>
<script type="text/javascript" 
  src="http://maps.google.com/maps/api/js?sensor=false"></script>
\end{listing}
}
\end{frame}
\begin{frame}[containsverbatim]
\frametitle{\texttt{Google Maps} の利用(2)}
{\small
\begin{listingcont}
<script type="text/javascript">
window.onload = function() {
  var latlng = new google.maps.LatLng(35.486210,139.341443);
  var myOptions = {
    zoom: 10,
    center: latlng,
    mapTypeId: google.maps.MapTypeId.ROADMAP
  };
  var mapCanvas = document.getElementById("map_canvas")
  var map = new google.maps.Map(mapCanvas, myOptions);
}
</script>
<link rel="stylesheet" type="text/css" href="map.css" /> 
</head>
<body>
  <div id="map_canvas" ></div>
</body>
</html> 
\end{listingcont}
}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{リストの解説(1)}
\begin{itemize}
 \item 1行目はHTML文書の\texttt{DOCTYPE}宣言である。この形はHTML5にお
       けるもの
 \item 2行目はこのHTML文書のルート要素と呼ばれるものである。最後の26行目
       の \Elm{/html}までが有効となる。
 \item すべての要素はこの範囲になければならない。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{リストの解説(2)--\texttt{<head>}}
3行目から始まる\Elm{head}はブラウザに表示されない、いろいろ
       なHTML文書の情報を表す。
 \begin{itemize}
  \item 4,5行目はこの文書の形式や文字集合を記述している。ここでは
	内容は\texttt{text/html}の形式、つまり、テキストで書かれ
	た\texttt{html}の形式で書かれていることを表す。
	\footnote{このような方法でファイルのデータ形式を表すこと
	をMIME(Multipurpose
	Internet Mail Extension)タイプと呼ぶ。元来、テキストデー
	タしか扱えない電子メールに様々なフォーマットのデータを扱
	えるようにする規格である。}
  \item 6行目の\Elm{title}はブラウザのタブに表示される文字
	列を指定している。
  \item 7,8行目はGoogle Maps のライブラリーを読み込むため
	のものである。このようにJavaScriptのプログラムは外部ファ
	イルとすることができる。
  \item 9行目から20行目はHTML文書内に書かれたJavaScriptである。
	詳しい解説は後の授業で行う。
  \item 20行目はHTML文書の見栄えなどを規定する\texttt{CSS}ファイ
	ルを外部から読み込むことをしている。
 \end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{リストの解説(2)--\texttt{<body>}}
HTML文書で実際にブラウザ内で表示される情報は\Elm{body}要素
       内に現れる。
\begin{itemize}
 \item このリストではGoogle Mapsを表示するための\Elm{div}要素が一つ
       あるだけである。このとき、\Elm{div}は\Elm{body}の子要素
       であるといい、\Elm{body}は\Elm{div}の親要素という。
 \item 各要素名または要素の終了を示すタグ(\texttt{<...>})の間に文字列が
       ある場合、その部分はテキストノードと呼ばれるノードが作成されてい
       る。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{要素の構成について}
各要素は\texttt{<}と\texttt{}の中に現れる。初めに現れる文字列が要素名で
 あり、そのあとに属性と属性値がいくつか並ぶ。
\begin{itemize}
 \item 属性とその属性値は\texttt{=}で結ばれる。
 \item 属性値は\texttt{”}ではさまれた文字列として記述
 \item \Elm{script}要素では属性\texttt{type}と\texttt{src}が
       設定
 \item 24行目の\Elm{div}要素では属性\texttt{id}に属性値
       \texttt{map\textunderscore canvas}を設定している。なお、この要素
       はCSSによっても属性が定義されている。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{21行目で参照しているCSSファイル}
\begin{verbatim}
#map_canvas{
    width:500px;
    height:500px;
    float:left;
    margin:5px 10px 5px 10px;
}
\end{verbatim}
\begin{itemize}
 \item CSSの各構成要素はHTML文書の要素を選択するセレクタ(ここでは
       \verb+#map_canvas+)とそれに対する属性値の並び([属性]:[属性値];)か
       らなる。
 \item \verb+#+で始まるセレクタはそのあとの文字列を\Elm{id}の属性値に
       持つ要素に適用される。
 \item したがって、ここの規則は24行目の\Elm{div}要素に適用
 \item その内容はGoogle Maps が表示される画面の大きさ(\texttt{width}と
       \texttt{height})、配置の位置(\texttt{float})と要素の外に配置され
       る空白(\texttt{margin})を指定
\end{itemize}
\end{frame}
\section{CSSの利用}
\begin{frame}[containsverbatim]
 \frametitle{CSSとは}
\begin{itemize}
 \item カスケーディングスタイルシート(CSS)はHTML文書の要素の表示方法を指定する
もの
 \item CSSはJavaScriptからも制御可能
 \item 文書のある要素に適用されるスタイルルールは、複数の異なるルールを結合(カ
スケード)したもの
 \item スタイルを適用するためには要素を選択するセレクタで選ぶ。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{セレクタの種類}
セレクタの種類は配布資料を参照のこと
いくつか注意する点を挙げる。
\begin{itemize}
 \item 属性\texttt{id}の属性値の前に\texttt{\#}をつけることでその要素が
       選ばれる。
 \item 属性\texttt{class}の属性値の前に\texttt{.}をつけることでその要素が
       選ばれる。
 \item \texttt{nth-child(n)}には単純な式を書くことができる。
このセレクタは複数書いても
       よい。
 \item \verb+E F+ と \verb+E > F+ の違いを理解しておくこと。たとえば
       \texttt{div div}というセレクタは途中に別の要素が挟まれていてもよ
       い。また、\texttt{<div>}要素が3つある場合にはどのような2つの組み
       合わせも対象となる。
\end{itemize}
\end{frame}
\section{DOMの利用}
\subsection{DOMとは}
\begin{frame}[containsverbatim]
 \frametitle{DOMとは}
\begin{itemize}
 \item Document Object Model(DOM)はHTML文書などの要素をノードとしたツリー構造で
管理する方法
 \item DOMのメソッドやプロパティを使うことで各要素にアクセ
スしたり、属性値やツリーの構造を変化させることが可能
 \item DOMの構造は開発者ツールなどで見ることができる。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{代表的なブラウザの開発者ツール}
\begin{itemize}
 \item Operaの開発者ツールからWebインスペクタを開き、Elementsタブで確
       認する。ここで要素上で右クリックしてEdit as HTML を選択するとテキ
       ストとして編集できる。
 \item Google Chromeでも同様な操作が可能
 \item FireFoxでは開発ツールから「開発ツールを表示」を
       選択し、インスペクタタブでDOMツリーが確認できる。要素上で右クリッ
       クから「HTMLとして編集」とするとテキストとして編集できる。
 \item IEでは開発者ツールを開き左にあるタブの一番上にあるDOM Explorerで同様の
       ことができる。
\end{itemize}
\end{frame}
\subsection{DOM のメソッド}
\begin{frame}[containsverbatim]
 \frametitle{DOM のメソッド}
DOM では DOM ツリーを操作するためにメソッドやプロパティが規定されている。
 メソッドとはそのオブジェクトに対する操作である。次のような手段を
       提供している。
\begin{itemize}
 \item 条件に合う要素または要素のリストを得る。
 \item 要素の属性を参照、変更ができる。
 \item 要素を新規に作成する。
 \item ある要素に子要素を追加したり、取り除いたりする。
\end{itemize}
\end{frame}
\newcommand{\DOMM}{\texttt}
\begin{frame}[containsverbatim]
 \frametitle{条件に合う要素または要素のリストを得る(1)}
\begin{itemize}
 \item \DOMM{getElementById}{(id)}\\
      属性\texttt{id}の値が引数\texttt{id}である要素を得る。
 \item \DOMM{getElementsByTagName}{(Name)}\\
     要素名が\texttt{Name}である要素のリストを得る。リストの各要素は
	  配列と同様に\texttt{[ ]}で参照できる。
 \item \DOMM{getElementsByClassName}{(Name)}\\
     属性\texttt{class}の値が\texttt{Name}である要素のリストを得る。リス
	  トの各要素は配列と同様に\texttt{[ ]}で参照できる。
 \item \DOMM{getElementsByName}{(Name)}\\
     属性\texttt{name}が\texttt{Name}である要素のリストを得る。得られた各要素は
	  配列と同様に\texttt{[ ]}で参照できる。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{条件に合う要素または要素のリストを得る(2)}
\begin{itemize}
 \item \DOMM{querySelector}{(selectors)}\\
     \texttt{selectors}で指定されたCSSのセレクタに該当する一番初めの要素
	  を得る
 \item \DOMM{querySelectorAll}{(selectors)}\\
     \texttt{selectors}で指定されたCSSのセレクタに該当する要素のリストを得る。
	  配列と同様に\texttt{[ ]}で参照できる
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{要素の属性を参照、変更ができる}
\begin{itemize}
 \item {\DOMM{getAttribute}{(Attrib)}} \\
     対象要素の属性\texttt{Attrib}の値を得る。戻り値の型は文字列である。
 \item {\DOMM{setAttribute}{(Attrib,Val)}} \\
     対象要素の属性\texttt{Attrib}の値を\texttt{Val}にする。数を渡しても
	  文字列に変換される。
 \item {\DOMM{hasAttribute}{(Attrib)}} \\
     対象要素に属性\texttt{Attrib}がある場合は\texttt{true}を、ない場合
 は\texttt{false}を返す。
 \item {\DOMM{removeAttribute}{(Attrib)}}\\
     対象要素の属性\texttt{Attrib}を削除
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{要素を新規に作成する}
\begin{itemize}
 \item \DOMM{createElement}{(Name)} \\
     \texttt{Name}で指定した要素を作成
 \item \DOMM{createElementNS}{(NS,Name)} \\
     {名前空間}\texttt{NS}で定義されている要素\texttt{Name}を作成
 \item \DOMM{createTextNode}{(text)}\\
     \texttt{text}を持つテキストノードを作成
 \item {\DOMM{cloneNode}{(bool)}} \\
\texttt{bool}が  \texttt{true}のときは対象要素の子要素すべてを、%複製する。
  \texttt{false}のときは対象要素だけの複製を作る。
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{名前空間}
\begin{itemize}
 \item 指定した要素が定義されている規格を指定するもの
 \item 一つの文書内で複数の規格を使用する場合、作成する要素がどこで定義
されているのかを指定
 \item 異なる規格で同じ要素名が定義されていてもそれらを区別することが可能
 \item 通常のHTML文書では\texttt{ http://www.w3.org/1999/xhtml}を指定
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{子要素の追加と削除}
\begin{itemize}
 \item {\DOMM{appendChild}{(Elm)}} \\
  \texttt{Elm}を対象要素の最後の子要素として付け加える。\texttt{Elm}がすでに
	  対称要素の子要素のときは元の位置から最後の位置に移動
 \item {\DOMM{insertBefore}{(newElm, PElm)}} \\
   対象要素の子要素\texttt{PElm}の前に\texttt{newElm}を子要素として付け
  加える。\texttt{Elm}がすでに対称要素の子要素のときは元の位置から指定さ
	  れた位置に移動
 \item \DOMM{removeChild}{(Elm)} \\
対象要素の子要素  \texttt{Elm}を取り除く。
 \item \DOMM{replaceChild}{(NewElm, OldElm)}
   対象要素に含まれる子要素  \texttt{OldElm}を\texttt{NewElm}で置き換え
       る。
 \item \DOMM{setValue}{(value)} \\
 {対象のテキストノードの値を\texttt{value}にする。}
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{プルダウンメニューの例}
1月から12月までを選択できるプルダウンメニューを作成
{\small
\begin{verbatim}
<body>
  <form id="menu">
    <select>
      <option value="1">1月</option>
      <option value="2">2月</option>
      <option value="3">3月</option>
      <option value="4">4月</option>
      <option value="5">5月</option>
      <option value="6">6月</option>
      <option value="7">7月</option>
      <option value="8">8月</option>
      <option value="9">9月</option>
      <option value="10">10月</option>
      <option value="11">11月</option>
      <option value="12">12月</option>
    </select>
  </form>
</body>
\end{verbatim}
}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{プルダウンメニュ――解説}
\begin{itemize}
 \item ユーザからの入力を受け付ける要素は通常、\Elm{form}要素内に記
       述
 \item プルダウンメニュ－の要素名は\Elm{select}
 \item 選択する内容は\Elm{option}要素
 \item \Elm{option}要素の属性\texttt{value}の値が選択した値として
       利用できる。
 \item \Elm{option}要素内の文字列(テキストノード)がプルダウンメニューに
       表示される
 \item \Elm{select}は\Elm{form}の子要素であり、各\Elm{option}は
       \Elm{select}の子要素
\end{itemize}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{プルダウンメニュ――プログラムで作成(1)}
\begin{listing}[5]{1}
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>プルダウンメニューの作成</title>
<script type="text/ecmascript">
//<![CDATA[
  window.onload = function(){
    var i;
    var Form = document.getElementById("menu");
    var Select = document.createElement("select");
    var Option, Text;
    Form.appendChild(Select);
\end{listing}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{プルダウンメニュ――プログラムで作成(2)}
\begin{listingcont}
    for(i=1;i<=12;i++) {
      Option = document.createElement("option");
      Option.setAttribute("value",i);
      Select.appendChild(Option);
      Text = document.createTextNode(i+"月");
      Option.appendChild(Text);
    }
  }
//]]>
</script>
</head>
<body>
  <form id="menu">
  </form>
</body>
</html> 
\end{listingcont}
\end{frame}
\begin{frame}[containsverbatim]
 \frametitle{プルダウンメニュ――プログラムで作成--解説}
\begin{itemize}
 \item 8行目の\texttt{window.onload}はファイルのロードが終わった後に発生
       するイベントを表す。\texttt{function()}が設定されているのでこの関
       数がロード後、実行
 \item 10行目では26行目から27行目にある\Elm{form}要素を得ている。
 \item 11行目では\Elm{select}要素を作成している。
 \item 13行目で11行目で作成した\Elm{select}要素を\Elm{form}要素の子要素
       に設定している。
 \item 14行目から始まる\texttt{for}ループで12個の\Elm{option}要素を作成
       し、\Elm{select}要素の子要素としている。
       \begin{itemize}
	\item 15行目で\Elm{option}要素を新規に作成している。
	\item 16行目で、その要素の属性\texttt{value}に値を設定している。
	\item 17行目ではその\Elm{option}要素を\Elm{select}要素の子要素と
	      している。
	\item さらに、18行目では表示する文字列をもつテキストノードを作成
	      し、19行目でそれを\Elm{option}要素の子要素としている。
       \end{itemize}
\end{itemize}
\end{frame}
\newcommand{\DOMP}{\texttt}
\subsection{DOMのプロパティ}
\begin{frame}[containsverbatim]
 \frametitle{DOMのプロパティ}
\begin{table}[ht]
\caption{DOM要素に対するプロパティ(1)}\label{PropertyDOM}
\begin{center}
 \begin{tabular}{|c|m{16zw}|}
  \hline
プロパティ名  &
 \hspace*{\fill}説{\hfill}明\hspace*{\fill}\rule{0em}{0em}\\ \hline
\DOMP{firstChild} &指定された要素の先頭にある子要素 \\ \hline
\DOMP{lastChild} & 指定された要素の最後にある子要素\\ \hline
\DOMP{nextSibling} & 指定された子要素の次の要素\\ \hline
\DOMP{previousSibling} & 現在の子要素の前にある要素\\ \hline
\DOMP{parentNode} & 現在の要素の親要素\\ \hline
\DOMP{hasChildNodes} &その要素が子要素を持つかどうか \\ \hline
\DOMP{nodeName}& その要素の要素名前\\ \hline
\DOMP{nodeType}& 要素の種類($1$は普通の要素、$3$はテキストノード)\\ \hline
\DOMP{nodeValue}&(テキスト)ノードの値 \\ \hline
\DOMP{childNodes}& 子要素の配列\\ \hline
 \end{tabular}
\end{center}
\end{table}
\end{frame}
\begin{frame}
 \begin{table}[ht]
\caption{DOM要素に対するプロパティ(2)---DOM4}
\begin{center}
 \begin{tabular}{|c|m{13zw}|}
  \hline
プロパティ名  &
 \hspace*{\fill}説{\hfill}明\hspace*{\fill}\rule{0em}{0em}\\ \hline
\DOMP{children}& 子要素のうち通常の要素だけからなる要素の配列\\ \hline
\DOMP{firstElementChild} &指定された要素の先頭にある通常の要素である子要素\\ \hline
\DOMP{lastElementChild} & 指定された要素の最後にある通常の要素である子要素\\ \hline
\DOMP{nextElementSibling} & 指定された子要素の次の通常の要素\\ \hline
\DOMP{previousElementSibling} & 現在の子要素の前にある通常の要素\\ \hline
 \end{tabular}
\end{center}
\end{table}
\end{frame}
\section{レポート問題}
\begin{frame}[containsverbatim]
 \frametitle{レポート問題}
課題7.1から7.4までレポートにして提出のこと。
\end{frame}
\end{document}
\begin{frame}[containsverbatim]
 \frametitle{}
\end{frame}


表\ref{CSS3selector}はCSS3におけるセレクタを記述したものである
\footnote{\protect\texttt{http://www.w3.org/TR/selectors/}より引用。}。
\begin{longtable}{|m{13em}|m{30zw}|}
 \caption{CSS3のセレクタ}\label{CSS3selector}\\
\hline
\multicolumn{1}{|c|}{セレクタ}&\multicolumn{1}{c|}{解説}\\\hline
\endfirsthead
 \caption{CSS3のセレクタ(続き)}\\
\hline
\multicolumn{1}{|c|}{セレクタ}&\multicolumn{1}{c|}{解説}\\\hline
\endhead
\hline\multicolumn{2}{r}{次ページへ続く}
\endfoot
\hline
\endlastfoot
\verb+*+&任意の要素%&Universal selector&2
\\\hline
\verb+E+&タイプが \verb+E+ の要素%&Type selector&1
\\\hline
\verb+E[foo]+&タイプが \verb+E+ で属性 \verb+"foo"+ を持つ要素%&Attribute
	 %selectors
\\\hline
\verb+E[foo="bar"]+&タイプが \verb+E+ で属性 \verb+"foo"+ の属性値が
     \verb+"bar"+である要素%&Attribute selectors
\\\hline
\verb+E[foo~="bar"]+&タイプが \verb+E+ で属性 \verb+"foo"+ の属性値が
     スペースで区切られたリストでその一つが \verb+"bar"+である要素%&Attribute selectors
\\\hline
\verb+E[foo^="bar"]+&タイプが \verb+E+ で属性 \verb+"foo"+ の属性値が
     \verb+"bar"+で始まる要素
%&Attribute selectors
\\\hline
\verb+E[foo$="bar"]+&タイプが \verb+E+ で属性 \verb+"foo"+ の属性値が
     \verb+"bar"+で終わる要素%&Attribute selectors
\\\hline
\verb+E[foo*="bar"]+&タイプが \verb+E+ で属性 \verb+"foo"+ の属性値が
     \verb+"bar"+を含む要素%&Attribute selectors
\\\hline
\verb+E[foo|="en"]+&タイプが \verb+E+ で属性 \verb+"foo"+ の属性値が
     ハイフンで区切られたリストでその一つが \verb+"en"+で始まる要素
     %&Attribute selectors
\\\hline
\verb+E:root+&\texttt{document}のルート要素%&Structural
	 %pseudo-classes
\\\hline
\verb+E:nth-child(n)+&親から見て\texttt{n}番目の要素%&Structural pseudo-classes
\\\hline
\verb+E:nth-last-child(n)+&親から見て最後から数えて\texttt{n}番目の要素
     %&Structural pseudo-classes 
\\\hline
\verb+E:nth-of-type(n)+&そのタイプの\texttt{n}番目の要素%&Structural pseudo-classes
\\\hline
\verb+E:nth-last-of-type(n)+&そのタイプの最後から\texttt{n}番目の要素%&Structural pseudo-classes
\\\hline
\verb+E:first-child+&親から見て一番初めの子要素%&Structural
	 %pseudo-classes
\\\hline
\verb+E:last-child+&親から見て一番最後の子要素%&Structural　 %pseudo-classes
\\\hline
\verb+E:first-of-type+&親から見て初めてのタイプである要素%&Structural pseudo-classes
\\\hline
\verb+E:last-of-type+&親から見て最後のタイプである要素%&Structural
	 %pseudo-classes
\\\hline
\verb+E:only-child+&親から見てただ一つしかない子要素%&Structural
	 %pseudo-classes
\\\hline
\verb+E:only-of-type+&親から見てただ一つしかないタイプの要素%&Structural
	 %pseudo-classes
\\\hline
\verb+E:empty+&テキストノードを含めて子要素がない要素%&Structural pseudo-classes
\\\hline
\verb+E:link+, %\newline
\verb+E:visited+&まだ訪れたことがない(\texttt{:link})か訪れたことがある
     (\texttt{visited})ハイパーリンクのアンカーである要素%&The link pseudo-classes+&1
\\\hline
\verb+E:active+, %\newline
\verb+E:hover+, %\newline
\verb+E:focus+&ユーザーに操作されている状態中の要素%&The user action
	 %pseudo-classes+&1 and 2
\\\hline
\verb+E:target+&参照URIのターゲットである要素%&The
	 %target pseudo-class
\\\hline
%\verb+E:lang(fr)+&an element of type E in language "fr" (the document
%     language specifies how language is determined)%&The :lang()
	 %pseudo-class
%\\\hline
\verb+E:enabled+, %\newline
\verb+E:disabled+&使用可能(\texttt{:enable})か使用不可のユーザーインター
     フェイスの要素%&The UI element states pseudo-classes
\\\hline
\verb+E:checked+&チェックされているユーザーインターフェイスの要素%&The UI element states
	 %pseudo-classes
\\\hline
\verb+E::first-line+&要素のフォーマットされたはじめの行%&The
	 %::first-line pseudo-element+&1
\\\hline
\verb+E::first-letter+&要素のフォーマットされたはじめの行%&The
	 %::first-letter pseudo-element&1
\\\hline
\verb+E::before+&要素の前に生成されたコンテント%&The ::before
	 %pseudo-element
\\\hline
\verb+E::after+&要素の後に生成されたコンテント%&The ::after
	 %pseudo-element
\\\hline
\verb+E.warning+&属性\texttt{class} が "warning" である要素%&Class selectors&1
\\\hline
\verb+E#myid+&属性\texttt{id} の属性値が "myid" である要素%&ID selectors&1
\\\hline
\verb+E:not(s)+&単純なセレクタ \texttt{s} にマッチしない要素%&Negation pseudo-class
\\\hline
\verb+E F+&要素\texttt{E} の子孫である要素\texttt{F}%&Descendant
	 %combinator&1
\\\hline
\verb+E > F+&要素\texttt{E} の子である要素\texttt{F}%&Child combinator
\\\hline
\verb+E + F+&要素\texttt{E} の直後にある要素\texttt{F}%&Adjacent
	 %sibling combinator
\\\hline
\verb+E ~ F+&要素\texttt{E} の直前にある要素\texttt{F}%&General sibling
	 %combinator
\\\hline
\end{longtable}


\begin{Prob}\upshape\label{nth-child}
次のHTML文書において\texttt{nth-child}の\texttt{()}内に次の式を入れた時
 どうなるか報告しなさい。ここで\texttt{<ol>}は箇条書きの開始を示す要素で
 あり、\texttt{<li>}は箇条書きの各項目を示す要素である。
\listinginput{1}{08-01nth-child.html}
\begin{enumerate}
 \item \texttt{n}(ここでのリストの設定)
 \item \texttt{2n}
 \item \texttt{n+3}
 \item \texttt{-n+2}
\end{enumerate}
\end{Prob}
\begin{Prob}\upshape
前問のリストに対し、背景色が次のようになるようにCSSを設定しなさい。
\begin{enumerate}
 \item 偶数番目が黄色、基数番目がオレンジ色
 \item 1番目、4番目、\dots のように$3$で割ったとき、$1$ 余る位置が明るい
       グレー
 \item 4番目以下がピンク
 \item 下から2番目以下が緑色
\end{enumerate}
\end{Prob}

\newcommand{\DOMM}{\texttt}
\newcommand{\DOMP}{\texttt}
\newcommand{\DOM}{\texttt{DOM}}
\newcommand{\keyitem}{\relax}
\newcommand{\HTML}{HTML文書}
%\DOM の構造や属性値の操作をプログラムから可能にするために

これらの手段を用いてDOM をサポートする文書にアクセスができる。

プロパティはそのオブジェクトが持つ性質であり、それらの値を参照できる。ほ
とんどのプロパティは書き直しできない。

なお、ここでのメソッドやプロパティは DOM文書で使用可能なものである。したがっ
て、\HTML も \DOM{} をサポートするブラウザであれば同様の方法で
部分的に書き直すことが可能である。
\subsubsection{DOMのメソッド}
%\input 08DOMMethod.tex
%-*- coding: utf-8 -*-

実行例\ref{ExGoogleMaps}では16行目でGoogle Mapsを表示する\Elm{div}
要素を得て、17行目でその要素内に地図を表示するように指定している。
\begin{Exec}\upshape\label{PullDown}
 次の例は
\begin{verbatim}
\end{verbatim}
\end{Exec}
\begin{Prob}\upshape
実行例\ref{PullDown}に対して次のことを行いなさい。
\begin{enumerate}
 \item ブラウザのコンテキストメニュ(右クリック)から「ページのソースを表
       示」を選択して、ソースコードがどうなっているか確認する。
 \item DOMツリーが正しくできていることを確認する。
 \item 8行目と21行目を取り除いた場合に起こることを確認する。また、その理
       由を考える。
 \item \Elm{select}要素を構成する部分を関数化して、月だけでなく日(1日か
       ら31日)が選べるプルダウンメニューを作る。
\end{enumerate}
\end{Prob}
\subsubsection{DOMのプロパティ}
表\ref{PropertyDOM}は DOM の要素に対するプロパティである。該当するものがな
い場合には \texttt{null} の値になる。これらのプロパティのうち、
\texttt{nodeValue}を除いてはすべて、読み取り専用である。
ある要素に子要素がない場合にはその要素の\texttt{firstChild}や
\texttt{lastChild}は\texttt{null}となる。同様に、ある要素に子要素がある
場合、その\texttt{firstChild.previousSibling}や
\texttt{lastChild.nextSibling}も\texttt{null}となる。

プロパティに関する例はイベント処理のところで示す。
\subsection{イベント処理}
\input 08Event.tex

