%-*- coding: utf-8 -*-
\chapter{オブジェクトの詳細}
\section{\protect\texttt{class}の実体}
\ES ではキーワード\ElmJ{class}が導入されたが、その実体はこれまでの
ECMASript に新しい機能を追加したわけではなく、従来のオブジェクトや継承に
関して記述を簡単にしたものに過ぎない\footnote{このことを syntactic
sugar(糖衣構文)と呼ぶ。}。実行例\ref{ExecconstructorClass}に
おいて\texttt{typeof Person}の結果は次のとおりである。
\begin{Verbatim}
>typeof Person;
"function"
\end{Verbatim}
従来の EcmaSCript では関数を用いてクラスが定義されていて、それの手法が使
われていることを示す。
\begin{Exec}\label{constructor}\upshape
次の例はコンストラクタ関数を用いて、前の例と同じオブジェクト(インスタン
 ス)を構成している。

 実行例\ref{ExecconstructorClass}の例で確認する。
\begin{Verbatim}
function PersonF(name, year, month, day, hometown = "神奈川"){
    this.name = name;
    this.birthday = {
      year : year,
      month : month,
      day : day
    };
    this["hometown"] = hometown;
}
\end{Verbatim}
 この定義では\ElmJ{constructor}の内容をそのまま関数にしているに過ぎない。
 なお、ここではメソッドなどが定義されていないが、それについては後で解説
 をする。
 \end{Exec}
\begin{Verbatim}
>p = new PersonF("foo",2001,4,1);
PersonF {name: "foo", birthday: {…}, hometown: "神奈川"}
\end{Verbatim}
\section{オブジェクト属性}
JavaScriptの関数オブジェクトには\ElmJ{prototype}、\ElmJ{class}と
\ElmJ{extensible}という３つの属性がある。\ElmJ{prototype}属性はオブジェ
クトの継承に関係するので、最後に説明をする。
\subsection{\protect\ElmJ{class}属性}
オブジェクトの\ElmJ{class}属性はオブジェクトの型情報を表す文字列である。
最新の \JS でもこの属性を設定する方法はない。直接値を取得する方
法もない。クラス属性は間接的にしか得られない。
組み込みのコンストラクタで生成されたオブジェクトではそのクラス名が間接的
に得られるが、独自のコンストラクタ関数では、\texttt{"Object"}しか得られ
ない。
\begin{Exec}\upshape\label{}
\ElmJ{Object}から継承した\ElmJ{toString()}を直接呼び出すと次のような結果
になる。
\begin{Verbatim}
>p = new PersonF("foo",2001,4,1);
PersonF {name: "foo", birthday: {…}, hometown: "神奈川"}
>`${p}`;
"[object Object]"
\end{Verbatim}
ここで、\texttt{Person()}コンストラクタには\ElmJ{toString()}メソッドが定
義されていないので、もともとの\ElmJ{Object}で定義されている
 \texttt{toString()}が呼び出されている。
\end{Exec}


\iffalse
 \ElmJ{Array()}オブジェクトには
\texttt{toString()}が定義(オーバーライド)されているので次のような形にし
ないとこのような結果が得られない。
\begin{Verbatim}
>Object.prototype.toString.call([]);
"[object Array]"
\end{Verbatim}
これは、\ElmJ{Object}の\ElmJ{prototype}属性に定義されている
\ElmJ{toString}を引数のメソッドとして利用することを意味する。
\ElmJ{prototype}の意味は後で説明をする。
同じように他のオブジェクトで実行すると次のようになる(Operaで実行)。
\begin{Verbatim}
>Object.prototype.toString.call(null);
"[object Null]"
>Object.prototype.toString.call(undefined);
"[object Undefined]"
>Object.prototype.toString.call(NaN);
"[object Number]"
>Object.prototype.toString.call(window);
"[object global]"
>window+""
"[object Window]"
\end{Verbatim}
なお、FireFoxやInternet Explorer では最後の例は次のようになる。
\begin{Verbatim}
>Object.prototype.toString.call(window);
"[object Window]"
>window+""
"[object Window]"
\end{Verbatim}
 \fi
\subsection{\protect\ElmJ{extensible}属性}
\ElmJ{extensible}はオブジェクトに対してプロパティの追加ができるか
どうかを指定する。\JS ではこの属性の取得や設定ができる関数が用意され
ている。

この属性の取得は\ElmJ{Object.isExtensible()}に調べたいオブジェクトを引数
にして渡す。オブジェクトのプロパティを拡張できなくするためには
\ElmJ{Object.preventExtension()}に引数として設定したいオブジェクトを渡す。
 \begin{Exec}\upshape
  実行例\ref{Execconstructor}の例で確認する。
\begin{Verbatim}
>p = new PersonF("foo",2001,4,1);
PersonF {name: "foo", birthday: {…}, hometown: "神奈川"}
>p.mother = "Alice";
Alice
>p.mother;
Alice
>p.mather = "Old Alice";
Old Alice
>p.grandmother;
Old Alice
>Object.preventExtensions(p);
 PersonF {name: "foo", birthday: {…}, hometown: "神奈川", mather: "Alice", grandmother: "Old Alice"}
>p.father = "Bob";
Bob
>p.father;
undefined
>delete p.mother;
true
>p.mother;
undefined
\end{Verbatim}
 \end{Exec}
\begin{itemize}
 \item \texttt{Object.preventExtensions(p)}を実行する前では存在しな
       い属性の追加ができている(\texttt{p.mother})。
 \item 設定後は、新しい属性が定義できていない(\texttt{p.father})。
 \item \texttt{Object.preventExtensions(p)}では属性の削除までは禁止でき
       ない(\texttt{delet p.mother}が成功している)。
\end{itemize}
属性の削除まで禁止したい場合には\ElmJ{Object.seal()}を用いる。一度この関
数を実行されたオブジェクトは解除できない。また、すで
にその状態になっているかどうかは、\ElmJ{Object.isSealed()}を用いる。
書き込み可の属性の値は変えることができる。
 \begin{Exec}\upshape\label{ExecContined}
  実行例\ref{Execconstructor}の例で確認する。
\begin{Verbatim}
>Object.seal(p);
PersonF {name: "foo", birthday: {…}, hometown: "神奈川", mather: "Alice", grandmother: "Old Alice"}
>Object.isSealed(p);
true
>delete p.grandmother;
false
>p.grandmother;
Old Alice
>p.grandmother = "Very Old Alice";
Very Old Alice
>p.grandmother;
Very Old Alice
\end{Verbatim}
 \end{Exec}
 \begin{itemize}
  \item \texttt{Object.seal()}を実行した後、存在しない属性
        \texttt{p.mother}は定義されていないことがわかる。
  \item 既存の属性の値は変更可能である。
 \end{itemize}
最も強く、オブジェクトを拘束するためには、\ElmJ{Object.freeze()}を用いる。
また、この状態を確認するためには\ElmJ{Object.isFrozen()}を用いる。
  \begin{Exec}\upshape
   実行例\ref{ExecContined}に引き続いて\ElmJ{Object.freeze()}を実行した
   結果である
 \end{Exec}
\begin{Verbatim}
>Object.isFrozen(p);
false
>Object.freeze(p);
PersonF {name: "foo", birthday: {…}, hometown: "神奈川", mather: "Alice", grandmother: "Very Old Alice"}
>p.grandmother = "Very Very Old Alice";
Very Very Old Alice
>;
>p.grandmother;
Very Old Alice
\end{Verbatim}
 \texttt{p.grandmother}の値が設定できていないことがわかる。
このような状態で属性値を変えたい場合には、属性にたいするセッターメソッド
を定義することになる。

 \iffalse
 なお、\texttt{Object.seal()}や \texttt{Object.freeze()}の影響は、渡され
 たオブジェクト自身の属性にしか影響を及ぼさない。継承元のオブジェクトに
 は影響を及ぼさない。
 \fi
 \subsection{\protect\ElmJ{prototye}属性}
 オブジェクトの\ElmJ{prototype}属性の値は、同じコンストラクタ関数で生成
 された間で共通のものになっている。オブジェクトリテラルで生成されたオブ
 ジェクトは\ElmJ{Object.prototype}で参照できる。\ElmJ{new}を用いて生成さ
 れたオブジェクトはそのコンストラクタ関数の\ElmJ{prototype}を参照する。
 このコンストラクタ関数の\ElmJ{prototype}もオブジェクトであるから、それ
 の\ElmJ{prototype}も存在する。この一連の\ElmJ{prototype}オブジェクトを
 プロトタイプチェーンとよぶ。

 \JS で定義されている \ElmJ{Object.create()} メソッドは引数で与
 えられたオブジェクトの\ElmJ{prototype}を\ElmJ{prototype}に持つオブジェ
 クトを生成する。このメソッドに対して2番目の引数を与えて、新たに生成され
 たオブジェクトのプロパティを指定できる。
 \subsection{\protect\texttt{prototype}の使用例}
 \begin{Exec}\upshape\label{ExecConst2}
  次の例は\ref{Execconstructor}の属性を簡略し、いくつかのメソッ
 ドを追加したものである。
\begin{Verbatim}[numbers=left]
PersonF.prototype = {
  toString:function() {
    return `${this.name}さんは`+
      `${this.birthday.year}年${this.birthday.month}月${this.birthday.day}日に` +
   `${this.hometown}で生まれました。`;
  },
  get age(){
    let today = new Date();console.log(x);
    let age = today.getFullYear() - this.birthday.year;
    if(today.getTime() <
         new Date(today.getFullYear(),
                  this.birthday.month-1,
                  this.birthday.day).getTime()) age--;
    return age;
  },
  constructor: PersonF
}
\end{Verbatim}
 \end{Exec}
これらの定義は前と同じである。オブジェクトリテラルの形式で
\ElmJ{prototype}に代入している。異なるところは\ElmJ{constructor}プロパティ
に自分自身を定義しているところである。

なお、\ElmJ{get}キーワードの代わりに\ElmJ{set}キーワードを用いるとセッター
を定義できる。

\begin{Prob}\upshape
 実行例\ref{Execconst3}において、\texttt{age}プロパティがセッターとして
 使われたときには注意を促すメッセージを表示するようにしなさい。
\end{Prob}
\section{関数によるオブジェクトの継承}
\JS では\ElmJ{prototype}を用
いることでメソッドの継承が可能となっている。
\begin{Exec}\upshape\label{Execconst4}
次のリストは実行例\ref{Execconst3}の\texttt{Person2}を継承して、学籍番号
 を追加のプロパティとする\texttt{Student}オブジェクトのコンストラクタ関
 数である。
\begin{Verbatim}[numbers=left]
const StudentF = (function(){
  let id = 10000;
  return function(name, year, month, day, hometown = "神奈川") {
    this.name = name
    this.birthday = {
      year : year,
      month : month,
      day : day
    };
    this["hometown"] = hometown;
    this.id = id++;
    }
  })();
StudentF.prototype = new PersonF();
StudentF.prototype.constructor = StudentF;
\end{Verbatim}
\end{Exec}
\iffalse
\begin{itemize}
 \item \texttt{name}などのプロパティはオブジェクトごとに違う値をとるので
       \texttt{Person2.rototype}内には置くことができない。したがって、そ
       れぞれを\texttt{this}のプロパティに格納する(２行目から６行目)。
 \item \texttt{Person2}の\texttt{prototype}を利用するために、
       \texttt{Student.prototype}にオブジェクトを新規に作成して代入する
       (8行目)。これにより、この後で\texttt{Person2}のプロパティが変更さ
       れても、\texttt{Student}オブジェクトには影響がでない。
 \item \texttt{Student.prototype.constructor}を\texttt{Student}に戻して
       おく(9行目)
\end{itemize}
実行結果は次のとおりである。
\begin{Verbatim}
>s = new Student("me",1323300,1995,4,1)
Student {name: "me", year: 1995, month: 4, day: 1, id: 1323300}
>s.age;
20
>s.name
"me"
>s+"";
"私の名前はmeです"
>s.constructor;
Student(n, id, y, m, d){
  this.name   = n;
  this.year  = y;
  this.month = m;
  this.day   = d;
  this.id    = id;
}
\end{Verbatim}
\texttt{Person2}で定義されたメソッドが利用できていることがわかる。
 \begin{Prob}\upshape
	実行例\ref{Execconst4}の\texttt{Student}に所属学部を表示するメソッドを
	追加しなさい。所属学部のプロパティは追加しないで学籍番号から求めること。
\end{Prob}
\fi
 \section{エラーオブジェクトについて}
エラーオブジェクトとはエラーが発生したことを知らせるオブジェクトである。
通常は計算の継続ができなくなったときにエラーオブジェクトをシステムに送る
操作が必要である。これを通常、エラーを投げる(\ElmJ{throw}する)という。
エラーオブジェクトには表\ref{ErrorProp}のようなプロパティがある。
\begin{table}
 \caption{エラーオブジェクトのプロパティ}\label{ErrorProp}
 \begin{center}
	 \begin{tabular}{|c|m{30zw}|}\hline
		プロパティ&\multicolumn{1}{c|}{説明}\\ \hline
		\texttt{message}&エラーに関する詳細なメッセージ。コンストラクタで渡
				された文字列か、デフォルトの文字列\\ \hline
		\texttt{name}&エラーの名前。エラーを作成したコンストラクタ名になる\\ \hline

	\end{tabular}
 \end{center}
\end{table}
\subsection{エラー処理の例}
エラー処理の例をいくつか挙げる。
 \begin{Exec}\upshape\label{throwError}
	次のリストは、実行例\ref{Execconst3}において、コンストラクタに与えられ
	た引数をチェックして不正な値の場合にはエラーを投げるように書き直したも
	のである。

	なお、このリストでは\texttt{Person2}の\texttt{age}の内容が以前のものと
	同じなので \texttt{...} で省略している。
 \end{Exec}
\begin{Verbatim}[numbers=left]
class Person{
  static checkName(name) {
    if(name === "") throw new Error("名前がありません");
    return name;
  }
  static checkDate(y, m, d) {
    if(m<1 || m>12) throw new Error("月が不正です");
    let date = new Date(y,m,0);
    if(d<1 || d>date.getDate()) throw new Error("日が不正です");
    return {year: y, month: m, day: d};
  }
  constructor(name, year, month, day, hometown="神奈川"){
    this.name = Person.checkName(name);
    this.birthday = Person.checkDate(year, month, day);
    this["hometown"] = hometown;
  }
  toString() {
    return `${this.name}さんは`+
      `${this.birthday.year}年${this.birthday.month}月${this.birthday.day}日に}` +
   `${this.hometown}で生まれました。`;
  }
  get age(){
    let today = new Date();
    let age = today.getFullYear() - this.birthday.year;
    if(today.getTime() <
         new Date(today.getFullYear(),
                  this.birthday.month-1,
                  this.birthday.day).getTime()) age--;
    return age;
  }
}
const Student = (function(){
  let id = 10000;
  return class extends Person {
    constructor(name, year, month, day, hometown) {
      super(name, year, month, day, hometown);
      this.id = id++;
    }
  }
})();
\end{Verbatim}
\begin{itemize}
 \item 2行目で、\texttt{name} が空文字であればエラーを発生させている。
 \item 5行目では月の値の範囲をチェックしている。
 \item 6行目では、与えられた年と月からその月の最終の日を求めている。
			 \ElmJ{Date.getMonth()}の戻り値が0(1月)から11(12月)になっているの
			 で、\texttt{new Date(y,m,0)}により翌月の1日の1日前、つまり、問題
			 としている月の最終日が設定できる\footnote{課題\ref{DateProb}
			 の3番目の問題の解答である。}。
 \item 7行目で与えられた範囲に日が含まれていなければエラーを発生させてい
			 る。
\end{itemize}
これをいくつかのデータで実行した結果は次のようになる。
\begin{itemize}
 \item 通常の日時ならば問題なく、オブジェクトが構成される。
\begin{Verbatim}
>p = new Person("foo",1995,4,1);
Person {name: "foo", year: 1995, month: 4, day: 1}
\end{Verbatim}
 \item 1996年はうるう年なので2月29日が存在する。したがって、エラーは起こ
			 らず正しくオブジェクトが作成できる。
\begin{Verbatim}
>p = new Person("foo",1996,2,29);
Person {name: "foo", year: 1996, month: 2, day: 29}
\end{Verbatim}
 \item 1995年はうるう年ではないので2月29日がない。したがって、エラーが起
			 きる。
\begin{Verbatim}
>p = new Person("foo",1995,2,29);
 Uncaught Error: 日が不正です(…)
\end{Verbatim}
 \item 不正な月や日では当然、エラーが起こる。
\begin{Verbatim}
>p = new Person("foo",1995,13,29);
 Uncaught Error: 月が不正です(…)
>p = new Person("foo",1995,12,0);
 Uncaught Error: 日が不正です(…)
\end{Verbatim}
\end{itemize}
\begin{Prob}\upshape\label{CorrectErrorCheck}
 実行例\ref{throwError}においてエラーチェックが完全ではないことを指摘し、
 それを改良しなさい。
\end{Prob}
このリストの欠点はこのオブジェクトを継承するオブジェクトに対して、継承先
のオブジェクトに対してエラーチェックの部分を再び書く必要がある。
これを改良したのが次のリストである。
\begin{Exec}\upshape\label{Error2}
次のリストはエラーチェックの部分を関数化して、継承先でも同じようなチェッ
 クができるようにしたものである。
\begin{Verbatim}[numbers=left]
function Person2(name, y, m, d){
  this.checkDate(y, m, d);
  this.checkName(name);
  this.name = name;
  this.year = y;
  this.month = m,
  this.day = d
}
Person2.prototype = {
  toString : function(){
      return "私の名前は"+this.name+"です";
    },
  checkDate : function(y, m, d) {
      var date = new Date(y,m,0);
      if(m<1 || m>12) throw new Error("月が不正です");
      if(d<1 || d>date.getDate()) throw new Error("日が不正です");
    },
  checkName : function(name) {
      if(name === "") throw new Error("名前がありません");
    },
 get age(){
   ... // 内容は省略
    },
  get birthday() {
      return this.year+"年"+this.month+"月"+this.day+"日";
    }
}
\end{Verbatim}
 \end{Exec}
このリストではエラーチェックをする関数を作成して、それを
 \texttt{Person2.prototype}のなかに置いている。
\begin{itemize}
 \item 2行目と3行目でエラーチェックをする関数を呼び出している。この関数
			 はエラーが起きたときはエラーを投げるので、コンストラクタ関数の制
			 御から離れることとなる。
 \item それぞれのエラーチェックをする関数は13行目から17行目と18行目から
			 20行目に記述されている。
 \item 実行例\ref{Execconst4}における\texttt{Person2}継承した
			 \texttt{Student}オブジェクトは次のようになる。
\end{itemize}
\begin{Verbatim}[numbers=left]
function Student(n, id, y, m, d){
  this.checkDate(y, m, d);
  this.checkName(name);
  this.name   = n;
  this.year  = y;
  this.month = m;
  this.day   = d;
  this.id    = id;
}
Student.prototype = new Person2();
Student.prototype.constructor = Student;
\end{Verbatim}
これを実行すると\texttt{Person2}と同じように動作することがわかる。
\begin{Verbatim}
>s=new Student("foo",1223300,1995,12,1);
Student {name: "foo", year: 1995, month: 12, day: 1, id: 1223300}
>s=new Student("foo",1223300,1995,4,0);
 Uncaught Error: 日が不正です(…)
>s=new Student("foo",1223300,1995,13,1);
 Uncaught Error: 月が不正です(…)
\end{Verbatim}
\subsection{エラーからの復帰}
前節の例ではエラーが発生するとそこでプログラムの実行が止まってしまう。エ
ラーが発生したときに、投げられた(\ElmJ{throw}された)エラーを捕まえる
(\ElmJ{catch}する)ことが必要である。このためには\ElmJ{try\{...\}catch\{...\}}構文
を使用する。
 \begin{Exec}\upshape
	次のリストは\ElmJ{try\{...\}catch\{...\}}構文を用いてオブジェクトが正しくでき
	るまで繰り返す。
 なお、このリストはブラウザで実行することを想定している。
 \end{Exec}
\begin{Verbatim}[numbers=left]
function test() {
  var y, m, d;
  for(;;) {
    try {
      y = Number(prompt("生まれた年を西暦で入力してください"));
      m = Number(prompt("生まれた月を入力してください"));
      d = Number(prompt("生まれた日を入力してください"));
      return new Person2("foo", y, m, d);
    } catch(e) {
      console.log(e.name+":"+e.message);
    }
  }
}
\end{Verbatim}
\begin{itemize}
 \item テストを繰り返す関数\texttt{test()}が定義されている。
 \item 3行目では無限ループが定義されている。正しいパラメータが与えられた
			 ときに8行目で作成されたオブジェクトを戻り値にして関数の実行が終了
			 する。
 \item \ElmJ{try\{\}}内にはエラーが発生するかもしれないコードを中に含め
			 る。
	\begin{itemize}
	 \item ここでは年、月、日の入力を\ElmJ{prompt}用いてダイアログボックス
				 を表示させ、そこに入力させている。
	 \item 戻り値は文字列なので、\ElmJ{Number}で数に直している。
	\end{itemize}
 \item 与えられた入力が正しくなければエラーが投げられ、
			 \ElmJ{catch}\texttt{(e)}の中に制御が移る。
 \item \ElmJ{catch}\texttt{(e)}における\texttt{e}には発生したエラーオブ
			 ジェクトが渡されるので、コンソールにその情報を出力する(10行目)。
\end{itemize}
\ElmJ{try\{...\}catch\{\}}構文については次のようなこともある。
\begin{itemize}
 \item \ElmJ{finally\{\}}を付けることも
できます。\ElmJ{try\{...\}catch\{\}}内の部分は\texttt{try}や
\texttt{catch}の部分が実行された後必ず呼び出される\footnote{この例では
正常時には\ElmJ{return}が実行されるので呼び出されません。}。
 \item \ElmJ{try\{...\}catch\{...\}}構文は入れ子にできる。投げられたエラー
			 に一番近い\texttt{catch}にエラーがつかまる。
\end{itemize}
